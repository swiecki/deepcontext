{"version":3,"sources":["../src/cli.ts","../src/analyzer.ts","../src/utils.ts"],"sourcesContent":["import { resolve } from 'path';\nimport { analyzeImports } from './analyzer';\n\nasync function main() {\n  try {\n    const [,, path, depthArg = '0'] = process.argv;\n    \n    if (!path) {\n      console.error('Please provide a path to analyze');\n      console.error('Usage: deepcontext <path> [depth]');\n      console.error('Example: deepcontext admin-wrapper.tsx 2');\n      process.exit(1);\n    }\n\n    const depth = parseInt(depthArg, 10);\n    if (isNaN(depth) || depth < 0) {\n      console.error('Depth must be a non-negative number');\n      process.exit(1);\n    }\n    \n    const absolutePath = resolve(process.cwd(), path);\n    const result = await analyzeImports(absolutePath, depth);\n    \n    // Format and print the results\n    Object.entries(result.content).forEach(([filepath, content]) => {\n      console.log(`\\n# ${filepath}\\n`);\n      console.log(content);\n    });\n  } catch (error) {\n    console.error('Error:', error instanceof Error ? error.message : String(error));\n    process.exit(1);\n  }\n}\n\nmain();\n","import { stat } from 'fs/promises';\nimport { dirname, resolve } from 'path';\nimport { findTsFiles, processFile, resolveImportPath } from './utils';\n\n/**\n * Represents the result of analyzing imports in a Next.js project\n */\nexport interface AnalysisResult {\n  /** Map of file paths to their imported dependencies */\n  imports: Record<string, string[]>;\n  /** Map of file paths to their content */\n  content: Record<string, string>;\n}\n\n/**\n * Analyzes imports in a Next.js project starting from the given path\n * @param path - The path to analyze (file or directory)\n * @param maxDepth - Maximum depth to follow imports (0 means only analyze the initial file)\n * @returns Promise resolving to the analysis result\n */\nexport const analyzeImports = async (\n  path: string, \n  maxDepth: number = 0\n): Promise<AnalysisResult> => {\n  console.log(`\\nAnalyzing ${path} with max depth ${maxDepth}`);\n  const absolutePath = resolve(process.cwd(), path);\n  const stats = await stat(absolutePath);\n  \n  // Initialize result maps\n  const result: AnalysisResult = {\n    imports: {},\n    content: {}\n  };\n  \n  const processedPaths = new Set<string>();\n  \n  async function processFileRecursively(filePath: string, currentDepth: number) {\n    if (processedPaths.has(filePath)) {\n      console.log(`  [${currentDepth}] Already processed ${filePath}`);\n      return;\n    }\n    console.log(`\\n  [${currentDepth}] Processing ${filePath}`);\n    processedPaths.add(filePath);\n    \n    const node = await processFile(filePath);\n    result.content[node.path] = node.content;\n    \n    console.log(`  [${currentDepth}] Found imports:`, node.imports);\n    const resolvedImports = await Promise.all(\n      node.imports.map(importPath => \n        resolveImportPath(importPath, dirname(node.path))\n      )\n    );\n    console.log(`  [${currentDepth}] Resolved to:`, resolvedImports);\n    \n    result.imports[node.path] = resolvedImports;\n    \n    // Follow imports if we haven't reached max depth\n    if (currentDepth < maxDepth) {\n      console.log(`  [${currentDepth}] Following imports (depth < ${maxDepth})`);\n      for (const resolvedPath of resolvedImports) {\n        if (resolvedPath) {\n          try {\n            await stat(resolvedPath);\n            await processFileRecursively(resolvedPath, currentDepth + 1);\n          } catch (err: any) {\n            console.log(`  [${currentDepth}] Failed to process ${resolvedPath}:`, err?.message || String(err));\n          }\n        }\n      }\n    } else {\n      console.log(`  [${currentDepth}] Max depth reached, stopping`);\n    }\n  }\n  \n  // Process initial files\n  const initialFiles = stats.isDirectory() \n    ? await findTsFiles(absolutePath)\n    : [absolutePath];\n    \n  await Promise.all(initialFiles.map(file => processFileRecursively(file, 0)));\n  \n  return result;\n};\n","import { readFile, readdir, stat } from 'fs/promises';\nimport { join, resolve, relative, dirname } from 'path';\n\n/**\n * Represents a file and its dependencies\n */\nexport interface FileNode {\n  /** Absolute path to the file */\n  path: string;\n  /** Content of the file */\n  content: string;\n  /** Local import paths found in the file */\n  imports: string[];\n}\n\n/**\n * Checks if a file is a TypeScript/JavaScript file\n */\nexport const isJsOrTsFile = (path: string): boolean => {\n  return /\\.(js|jsx|ts|tsx)$/.test(path);\n};\n\n/**\n * Extracts local imports from TypeScript/JavaScript file content\n */\nexport const extractImports = (content: string): string[] => {\n  // Match both simple and destructured imports, including multi-line\n  const importRegex = /import\\s+(?:(?:[\\w*\\s{},]*)\\s+from\\s+)?['\"]([@./][^'\"]+)['\"]/g;\n  const imports: string[] = [];\n  let match;\n\n  // Handle multi-line content by normalizing newlines\n  const normalizedContent = content.replace(/\\r\\n/g, '\\n');\n\n  while ((match = importRegex.exec(normalizedContent)) !== null) {\n    console.log('  Found import match:', match[0], '-> path:', match[1]);\n    imports.push(match[1]);\n  }\n\n  return imports;\n};\n\n/**\n * Loads and parses tsconfig.json from the current directory or parent directories\n */\nexport const loadTsConfig = async (startDir: string): Promise<{ baseUrl?: string; paths?: Record<string, string[]>; tsconfigDir?: string }> => {\n  let currentDir = startDir;\n  \n  while (currentDir !== '/') {\n    try {\n      const tsconfigPath = join(currentDir, 'tsconfig.json');\n      await stat(tsconfigPath);\n      const content = await readFile(tsconfigPath, 'utf-8');\n      const tsconfig = JSON.parse(content);\n      console.log('  Found tsconfig at:', tsconfigPath);\n      console.log('  Paths:', tsconfig.compilerOptions?.paths);\n      return {\n        baseUrl: tsconfig.compilerOptions?.baseUrl,\n        paths: tsconfig.compilerOptions?.paths,\n        tsconfigDir: currentDir\n      };\n    } catch {\n      currentDir = dirname(currentDir);\n    }\n  }\n  \n  console.log('  No tsconfig.json found');\n  return {};\n};\n\n/**\n * Resolves a relative import path to an absolute file path\n */\nexport const resolveImportPath = async (importPath: string, currentDir: string): Promise<string> => {\n  console.log(`\\n  Resolving import: ${importPath} from ${currentDir}`);\n  \n  // Handle tsconfig paths for @ imports\n  if (importPath.startsWith('@')) {\n    console.log('  Import uses @ prefix, checking tsconfig paths');\n    const tsconfig = await loadTsConfig(currentDir);\n    if (tsconfig.paths && tsconfig.tsconfigDir) {\n      for (const [pattern, [replacement]] of Object.entries(tsconfig.paths)) {\n        const patternRegex = new RegExp('^' + pattern.replace('*', '(.*)') + '$');\n        const match = importPath.match(patternRegex);\n        if (match) {\n          console.log(`  Matched pattern ${pattern} -> ${replacement}`);\n          const baseDir = tsconfig.baseUrl ? join(tsconfig.tsconfigDir, tsconfig.baseUrl) : tsconfig.tsconfigDir;\n          const resolvedPath = join(baseDir, replacement.replace('*', match[1]));\n          console.log(`  Resolved to: ${resolvedPath}`);\n          return resolveImportPath(resolvedPath, baseDir);\n        }\n      }\n      console.log('  No matching pattern found in tsconfig paths');\n    }\n  }\n\n  // Handle index files\n  const resolvedPath = resolve(currentDir, importPath);\n  console.log(`  Trying path: ${resolvedPath}`);\n  const extensions = ['.tsx', '.ts', '.jsx', '.js'];\n  \n  // If path already has an extension, try it first\n  if (/\\.[^/.]+$/.test(importPath)) {\n    try {\n      await stat(resolvedPath);\n      console.log(`  Found exact match: ${resolvedPath}`);\n      return resolvedPath;\n    } catch {\n      console.log(`  Exact match not found: ${resolvedPath}`);\n    }\n  }\n  \n  // Try with each extension\n  for (const ext of extensions) {\n    const pathWithExt = resolvedPath + ext;\n    try {\n      await stat(pathWithExt);\n      console.log(`  Found with extension: ${pathWithExt}`);\n      return pathWithExt;\n    } catch {\n      console.log(`  Not found with extension: ${pathWithExt}`);\n    }\n  }\n  \n  // Try as directory with index files\n  for (const ext of extensions) {\n    const indexPath = join(resolvedPath, `index${ext}`);\n    try {\n      await stat(indexPath);\n      console.log(`  Found index file: ${indexPath}`);\n      return indexPath;\n    } catch {\n      console.log(`  Index file not found: ${indexPath}`);\n    }\n  }\n  \n  console.log(`  Could not resolve ${importPath}, returning original resolved path`);\n  return resolvedPath;\n};\n\n/**\n * Reads a file and extracts its imports\n */\nexport const processFile = async (filePath: string): Promise<FileNode> => {\n  const content = await readFile(filePath, 'utf-8');\n  const imports = extractImports(content);\n  return {\n    path: filePath,\n    content,\n    imports\n  };\n};\n\n/**\n * Recursively finds all TypeScript/JavaScript files in a directory\n */\nexport const findTsFiles = async (dir: string): Promise<string[]> => {\n  const files: string[] = [];\n  \n  const entries = await readdir(dir, { withFileTypes: true });\n  \n  for (const entry of entries) {\n    const path = join(dir, entry.name);\n    \n    if (entry.isDirectory()) {\n      // Skip node_modules and other common exclude directories\n      if (['node_modules', '.git', 'dist'].includes(entry.name)) {\n        continue;\n      }\n      files.push(...await findTsFiles(path));\n    } else if (isJsOrTsFile(path)) {\n      files.push(path);\n    }\n  }\n  \n  return files;\n};\n"],"mappings":"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","names":["resolve","stat","dirname","resolve","resolvedPath","resolve","stat","dirname","resolve"]}