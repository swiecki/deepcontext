{"version":3,"sources":["../src/analyzer.ts","../src/utils.ts"],"sourcesContent":["import { stat } from 'fs/promises';\nimport { dirname, resolve } from 'path';\nimport { findTsFiles, processFile, resolveImportPath } from './utils';\n\n/**\n * Options for import analysis\n */\nexport interface AnalyzeOptions {\n  /** Enable debug logging */\n  debug?: boolean;\n}\n\n/**\n * Represents the result of analyzing imports in a Next.js project\n */\nexport interface AnalysisResult {\n  /** Map of file paths to their imported dependencies */\n  imports: Record<string, string[]>;\n  /** Map of file paths to their content */\n  content: Record<string, string>;\n}\n\n/**\n * Analyzes imports in a Next.js project starting from the given path\n * @param path - The path to analyze (file or directory)\n * @param maxDepth - Maximum depth to follow imports (0 means only analyze the initial file)\n * @param options - Analysis options\n * @returns Promise resolving to the analysis result\n */\nexport const analyzeImports = async (\n  path: string, \n  maxDepth: number = 0,\n  options: AnalyzeOptions = {}\n): Promise<AnalysisResult> => {\n  const log = (...args: any[]) => {\n    if (options.debug) {\n      console.log(...args);\n    }\n  };\n\n  log(`\\nAnalyzing ${path} with max depth ${maxDepth}`);\n  const absolutePath = resolve(process.cwd(), path);\n  const stats = await stat(absolutePath);\n  \n  // Initialize result maps\n  const result: AnalysisResult = {\n    imports: {},\n    content: {}\n  };\n  \n  const processedPaths = new Set<string>();\n  \n  async function processFileRecursively(filePath: string, currentDepth: number) {\n    if (processedPaths.has(filePath)) {\n      log(`  [${currentDepth}] Already processed ${filePath}`);\n      return;\n    }\n    log(`\\n  [${currentDepth}] Processing ${filePath}`);\n    processedPaths.add(filePath);\n    \n    const node = await processFile(filePath, options);\n    result.content[node.path] = node.content;\n    \n    log(`  [${currentDepth}] Found imports:`, node.imports);\n    const resolvedImports = await Promise.all(\n      node.imports.map(importPath => \n        resolveImportPath(importPath, dirname(node.path), options)\n      )\n    );\n    log(`  [${currentDepth}] Resolved to:`, resolvedImports);\n    \n    result.imports[node.path] = resolvedImports;\n    \n    // Follow imports if we haven't reached max depth\n    if (currentDepth < maxDepth) {\n      log(`  [${currentDepth}] Following imports (depth < ${maxDepth})`);\n      for (const resolvedPath of resolvedImports) {\n        if (resolvedPath) {\n          try {\n            await stat(resolvedPath);\n            await processFileRecursively(resolvedPath, currentDepth + 1);\n          } catch (err: any) {\n            log(`  [${currentDepth}] Failed to process ${resolvedPath}:`, err?.message || String(err));\n          }\n        }\n      }\n    } else {\n      log(`  [${currentDepth}] Max depth reached, stopping`);\n    }\n  }\n  \n  // Process initial files\n  const initialFiles = stats.isDirectory() \n    ? await findTsFiles(absolutePath)\n    : [absolutePath];\n    \n  await Promise.all(initialFiles.map(file => processFileRecursively(file, 0)));\n  \n  return result;\n};\n","import { readFile, readdir, stat } from 'fs/promises';\nimport { join, resolve, relative, dirname } from 'path';\nimport { AnalyzeOptions } from './analyzer';\n\n/**\n * Represents a file and its dependencies\n */\nexport interface FileNode {\n  /** Absolute path to the file */\n  path: string;\n  /** Content of the file */\n  content: string;\n  /** Local import paths found in the file */\n  imports: string[];\n}\n\n/**\n * Checks if a file is a TypeScript/JavaScript file\n */\nexport const isJsOrTsFile = (path: string): boolean => {\n  return /\\.(js|jsx|ts|tsx)$/.test(path);\n};\n\n/**\n * Extracts local imports from TypeScript/JavaScript file content\n */\nexport const extractImports = (content: string, options: AnalyzeOptions = {}): string[] => {\n  const log = (...args: any[]) => {\n    if (options.debug) {\n      console.log(...args);\n    }\n  };\n\n  // Match both simple and destructured imports, including multi-line\n  const importRegex = /import\\s+(?:(?:[\\w*\\s{},]*)\\s+from\\s+)?['\"]([@./][^'\"]+)['\"]/g;\n  const imports: string[] = [];\n  let match;\n\n  // Handle multi-line content by normalizing newlines\n  const normalizedContent = content.replace(/\\r\\n/g, '\\n');\n\n  while ((match = importRegex.exec(normalizedContent)) !== null) {\n    log('  Found import match:', match[0], '-> path:', match[1]);\n    imports.push(match[1]);\n  }\n\n  return imports;\n};\n\n/**\n * Loads and parses tsconfig.json from the current directory or parent directories\n */\nexport const loadTsConfig = async (startDir: string, options: AnalyzeOptions = {}): Promise<{ baseUrl?: string; paths?: Record<string, string[]>; tsconfigDir?: string }> => {\n  const log = (...args: any[]) => {\n    if (options.debug) {\n      console.log(...args);\n    }\n  };\n\n  let currentDir = startDir;\n  \n  while (currentDir !== '/') {\n    try {\n      const tsconfigPath = join(currentDir, 'tsconfig.json');\n      await stat(tsconfigPath);\n      const content = await readFile(tsconfigPath, 'utf-8');\n      const tsconfig = JSON.parse(content);\n      log('  Found tsconfig at:', tsconfigPath);\n      log('  Paths:', tsconfig.compilerOptions?.paths);\n      return {\n        baseUrl: tsconfig.compilerOptions?.baseUrl,\n        paths: tsconfig.compilerOptions?.paths,\n        tsconfigDir: currentDir\n      };\n    } catch {\n      currentDir = dirname(currentDir);\n    }\n  }\n  \n  log('  No tsconfig.json found');\n  return {};\n};\n\n/**\n * Resolves a relative import path to an absolute file path\n */\nexport const resolveImportPath = async (importPath: string, currentDir: string, options: AnalyzeOptions = {}): Promise<string> => {\n  const log = (...args: any[]) => {\n    if (options.debug) {\n      console.log(...args);\n    }\n  };\n\n  log(`\\n  Resolving import: ${importPath} from ${currentDir}`);\n  \n  // Handle tsconfig paths for @ imports\n  if (importPath.startsWith('@')) {\n    log('  Import uses @ prefix, checking tsconfig paths');\n    const tsconfig = await loadTsConfig(currentDir, options);\n    if (tsconfig.paths && tsconfig.tsconfigDir) {\n      for (const [pattern, [replacement]] of Object.entries(tsconfig.paths)) {\n        const patternRegex = new RegExp('^' + pattern.replace('*', '(.*)') + '$');\n        const match = importPath.match(patternRegex);\n        if (match) {\n          log(`  Matched pattern ${pattern} -> ${replacement}`);\n          const baseDir = tsconfig.baseUrl ? join(tsconfig.tsconfigDir, tsconfig.baseUrl) : tsconfig.tsconfigDir;\n          const resolvedPath = join(baseDir, replacement.replace('*', match[1]));\n          log(`  Resolved to: ${resolvedPath}`);\n          return resolveImportPath(resolvedPath, baseDir, options);\n        }\n      }\n      log('  No matching pattern found in tsconfig paths');\n    }\n  }\n\n  // Handle index files\n  const resolvedPath = resolve(currentDir, importPath);\n  log(`  Trying path: ${resolvedPath}`);\n  const extensions = ['.tsx', '.ts', '.jsx', '.js'];\n  \n  // If path already has an extension, try it first\n  if (/\\.[^/.]+$/.test(importPath)) {\n    try {\n      await stat(resolvedPath);\n      log(`  Found exact match: ${resolvedPath}`);\n      return resolvedPath;\n    } catch {\n      log(`  Exact match not found: ${resolvedPath}`);\n    }\n  }\n  \n  // Try with each extension\n  for (const ext of extensions) {\n    const pathWithExt = resolvedPath + ext;\n    try {\n      await stat(pathWithExt);\n      log(`  Found with extension: ${pathWithExt}`);\n      return pathWithExt;\n    } catch {\n      log(`  Not found with extension: ${pathWithExt}`);\n    }\n  }\n  \n  // Try as directory with index files\n  for (const ext of extensions) {\n    const indexPath = join(resolvedPath, `index${ext}`);\n    try {\n      await stat(indexPath);\n      log(`  Found index file: ${indexPath}`);\n      return indexPath;\n    } catch {\n      log(`  Index file not found: ${indexPath}`);\n    }\n  }\n  \n  log(`  Could not resolve ${importPath}, returning original resolved path`);\n  return resolvedPath;\n};\n\n/**\n * Reads a file and extracts its imports\n */\nexport const processFile = async (filePath: string, options: AnalyzeOptions = {}): Promise<{ path: string; content: string; imports: string[] }> => {\n  const content = await readFile(filePath, 'utf-8');\n  const imports = extractImports(content, options);\n  return {\n    path: filePath,\n    content,\n    imports\n  };\n};\n\n/**\n * Recursively finds all TypeScript/JavaScript files in a directory\n */\nexport const findTsFiles = async (dir: string): Promise<string[]> => {\n  const files: string[] = [];\n  \n  const entries = await readdir(dir, { withFileTypes: true });\n  \n  for (const entry of entries) {\n    const path = join(dir, entry.name);\n    \n    if (entry.isDirectory()) {\n      // Skip node_modules and other common exclude directories\n      if (['node_modules', '.git', 'dist'].includes(entry.name)) {\n        continue;\n      }\n      files.push(...await findTsFiles(path));\n    } else if (isJsOrTsFile(path)) {\n      files.push(path);\n    }\n  }\n  \n  return files;\n};\n"],"mappings":"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","names":["stat","dirname","resolve","resolvedPath","resolve","stat","dirname"]}