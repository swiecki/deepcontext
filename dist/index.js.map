{"version":3,"sources":["../src/analyzer.ts","../src/utils.ts"],"sourcesContent":["import { stat } from 'fs/promises';\nimport { dirname, resolve } from 'path';\nimport { FileNode, findTsFiles, processFile, resolveImportPath } from './utils';\n\n/**\n * Represents the result of analyzing imports in a Next.js project\n */\nexport interface AnalysisResult {\n  /** Map of file paths to their imported dependencies */\n  imports: Record<string, string[]>;\n  /** Map of file paths to their content */\n  content: Record<string, string>;\n}\n\n/**\n * Analyzes imports in a Next.js project starting from the given path\n * @param path - The path to analyze (file or directory)\n * @returns Promise resolving to the analysis result\n */\nexport const analyzeImports = async (path: string): Promise<AnalysisResult> => {\n  const absolutePath = resolve(process.cwd(), path);\n  const stats = await stat(absolutePath);\n  \n  // Initialize result maps\n  const result: AnalysisResult = {\n    imports: {},\n    content: {}\n  };\n  \n  // Process all files\n  const filesToProcess = stats.isDirectory() \n    ? await findTsFiles(absolutePath)\n    : [absolutePath];\n    \n  // Process each file and collect their nodes\n  const fileNodes: FileNode[] = await Promise.all(\n    filesToProcess.map(processFile)\n  );\n  \n  // Build the result maps\n  for (const node of fileNodes) {\n    // Store the content\n    result.content[node.path] = node.content;\n    \n    // Resolve and store imports\n    const resolvedImports = await Promise.all(\n      node.imports.map(importPath => \n        resolveImportPath(importPath, dirname(node.path))\n      )\n    );\n    \n    result.imports[node.path] = resolvedImports;\n  }\n  \n  return result;\n};\n","import { readFile, readdir, stat } from 'fs/promises';\nimport { join, resolve, relative, dirname } from 'path';\n\n/**\n * Represents a file and its dependencies\n */\nexport interface FileNode {\n  /** Absolute path to the file */\n  path: string;\n  /** Content of the file */\n  content: string;\n  /** Local import paths found in the file */\n  imports: string[];\n}\n\n/**\n * Checks if a file is a TypeScript/JavaScript file\n */\nexport const isJsOrTsFile = (path: string): boolean => {\n  return /\\.(js|jsx|ts|tsx)$/.test(path);\n};\n\n/**\n * Extracts local imports from TypeScript/JavaScript file content\n */\nexport const extractImports = (content: string): string[] => {\n  const importRegex = /import\\s+(?:(?:[\\w*\\s{},]*)\\s+from\\s+)?['\"]([./][^'\"]+)['\"]/g;\n  const imports: string[] = [];\n  let match;\n\n  while ((match = importRegex.exec(content)) !== null) {\n    imports.push(match[1]);\n  }\n\n  return imports;\n};\n\n/**\n * Resolves a relative import path to an absolute file path\n */\nexport const resolveImportPath = async (importPath: string, currentDir: string): Promise<string> => {\n  // Handle index files\n  const resolvedPath = resolve(currentDir, importPath);\n  const extensions = ['.tsx', '.ts', '.jsx', '.js'];\n  \n  // If path already has an extension, try it first\n  if (/\\.[^/.]+$/.test(importPath)) {\n    try {\n      await stat(resolvedPath);\n      return resolvedPath;\n    } catch {\n      // Continue to try other possibilities\n    }\n  }\n  \n  // Try with each extension\n  for (const ext of extensions) {\n    const pathWithExt = resolvedPath + ext;\n    try {\n      await stat(pathWithExt);\n      return pathWithExt;\n    } catch {\n      continue;\n    }\n  }\n  \n  // Try as directory with index files\n  for (const ext of extensions) {\n    const indexPath = join(resolvedPath, `index${ext}`);\n    try {\n      await stat(indexPath);\n      return indexPath;\n    } catch {\n      continue;\n    }\n  }\n  \n  // If nothing found, return original resolved path\n  return resolvedPath;\n};\n\n/**\n * Reads a file and extracts its imports\n */\nexport const processFile = async (filePath: string): Promise<FileNode> => {\n  const content = await readFile(filePath, 'utf-8');\n  const imports = extractImports(content);\n  return {\n    path: filePath,\n    content,\n    imports\n  };\n};\n\n/**\n * Recursively finds all TypeScript/JavaScript files in a directory\n */\nexport const findTsFiles = async (dir: string): Promise<string[]> => {\n  const files: string[] = [];\n  \n  const entries = await readdir(dir, { withFileTypes: true });\n  \n  for (const entry of entries) {\n    const path = join(dir, entry.name);\n    \n    if (entry.isDirectory()) {\n      // Skip node_modules and other common exclude directories\n      if (['node_modules', '.git', 'dist'].includes(entry.name)) {\n        continue;\n      }\n      files.push(...await findTsFiles(path));\n    } else if (isJsOrTsFile(path)) {\n      files.push(path);\n    }\n  }\n  \n  return files;\n};\n"],"mappings":";;;AAAA,SAAS,QAAAA,aAAY;AACrB,SAAS,WAAAC,UAAS,WAAAC,gBAAe;;;ACDjC,SAAS,UAAU,SAAS,YAAY;AACxC,SAAS,MAAM,eAAkC;AAiB1C,IAAM,eAAe,CAAC,SAA0B;AACrD,SAAO,qBAAqB,KAAK,IAAI;AACvC;AAKO,IAAM,iBAAiB,CAAC,YAA8B;AAC3D,QAAM,cAAc;AACpB,QAAM,UAAoB,CAAC;AAC3B,MAAI;AAEJ,UAAQ,QAAQ,YAAY,KAAK,OAAO,OAAO,MAAM;AACnD,YAAQ,KAAK,MAAM,CAAC,CAAC;AAAA,EACvB;AAEA,SAAO;AACT;AAKO,IAAM,oBAAoB,OAAO,YAAoB,eAAwC;AAElG,QAAM,eAAe,QAAQ,YAAY,UAAU;AACnD,QAAM,aAAa,CAAC,QAAQ,OAAO,QAAQ,KAAK;AAGhD,MAAI,YAAY,KAAK,UAAU,GAAG;AAChC,QAAI;AACF,YAAM,KAAK,YAAY;AACvB,aAAO;AAAA,IACT,QAAQ;AAAA,IAER;AAAA,EACF;AAGA,aAAW,OAAO,YAAY;AAC5B,UAAM,cAAc,eAAe;AACnC,QAAI;AACF,YAAM,KAAK,WAAW;AACtB,aAAO;AAAA,IACT,QAAQ;AACN;AAAA,IACF;AAAA,EACF;AAGA,aAAW,OAAO,YAAY;AAC5B,UAAM,YAAY,KAAK,cAAc,QAAQ,GAAG,EAAE;AAClD,QAAI;AACF,YAAM,KAAK,SAAS;AACpB,aAAO;AAAA,IACT,QAAQ;AACN;AAAA,IACF;AAAA,EACF;AAGA,SAAO;AACT;AAKO,IAAM,cAAc,OAAO,aAAwC;AACxE,QAAM,UAAU,MAAM,SAAS,UAAU,OAAO;AAChD,QAAM,UAAU,eAAe,OAAO;AACtC,SAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,IACA;AAAA,EACF;AACF;AAKO,IAAM,cAAc,OAAO,QAAmC;AACnE,QAAM,QAAkB,CAAC;AAEzB,QAAM,UAAU,MAAM,QAAQ,KAAK,EAAE,eAAe,KAAK,CAAC;AAE1D,aAAW,SAAS,SAAS;AAC3B,UAAM,OAAO,KAAK,KAAK,MAAM,IAAI;AAEjC,QAAI,MAAM,YAAY,GAAG;AAEvB,UAAI,CAAC,gBAAgB,QAAQ,MAAM,EAAE,SAAS,MAAM,IAAI,GAAG;AACzD;AAAA,MACF;AACA,YAAM,KAAK,GAAG,MAAM,YAAY,IAAI,CAAC;AAAA,IACvC,WAAW,aAAa,IAAI,GAAG;AAC7B,YAAM,KAAK,IAAI;AAAA,IACjB;AAAA,EACF;AAEA,SAAO;AACT;;;ADlGO,IAAM,iBAAiB,OAAO,SAA0C;AAC7E,QAAM,eAAeC,SAAQ,QAAQ,IAAI,GAAG,IAAI;AAChD,QAAM,QAAQ,MAAMC,MAAK,YAAY;AAGrC,QAAM,SAAyB;AAAA,IAC7B,SAAS,CAAC;AAAA,IACV,SAAS,CAAC;AAAA,EACZ;AAGA,QAAM,iBAAiB,MAAM,YAAY,IACrC,MAAM,YAAY,YAAY,IAC9B,CAAC,YAAY;AAGjB,QAAM,YAAwB,MAAM,QAAQ;AAAA,IAC1C,eAAe,IAAI,WAAW;AAAA,EAChC;AAGA,aAAW,QAAQ,WAAW;AAE5B,WAAO,QAAQ,KAAK,IAAI,IAAI,KAAK;AAGjC,UAAM,kBAAkB,MAAM,QAAQ;AAAA,MACpC,KAAK,QAAQ;AAAA,QAAI,gBACf,kBAAkB,YAAYC,SAAQ,KAAK,IAAI,CAAC;AAAA,MAClD;AAAA,IACF;AAEA,WAAO,QAAQ,KAAK,IAAI,IAAI;AAAA,EAC9B;AAEA,SAAO;AACT;","names":["stat","dirname","resolve","resolve","stat","dirname"]}